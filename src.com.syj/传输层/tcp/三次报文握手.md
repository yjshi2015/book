# TCP的连接建立

TCP建立连接的过程佳作握手，握手需要在客户端和服务端之间交换三个TCP报文段，如下图画出了三个报文握手建立TCP连接的过程
`![TCP三次握手](img/TCP_connect.png)`

假定主机A运行的是TCP客户程序，而B运行TCP服务器程序。最初两端的TCP进程都是CLOSED(关闭)状态。图中主机下面的方框分别
是TCP进程所处的状态。在本例中，**A主动打开连接**，而**B被动打开连接**

一开始，B的TCP服务器进程先创建**传输控制块TCB**,准备接受客户进程的连接请求。然后服务器进程就处于LISTEN(监听)状态，
等待客户端的连接请求。如有，即作出相应。

A的TCP客户进程也是先创建**传输控制块TCP**。然后，在打算建立TCP连接时，向B发出连接请求报文段，这是首部中的同步位
`SYN = 1`,同时选择一个初始序号 `seq = x`。`TCP规定：SYN报文段(即SYN = 1的报文段)不能携带数据，但要**消耗掉一
个序号**`。这时，TCP客户A进程进入`SYN-SENT(同步已发送)`状态。

B收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文段中应把`SYN位`和`ACK位`都置为1，确认号是
`ack = x + 1`,同时也为自己选择一个初始序号`seq = y`。注意：这个报文段也不能携带数据，但同样要消耗掉一个序号。这时，
TCP服务器B进程进入`SYN-RCVD(同步收到)`状态。

TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的ACK置为1，确认号`ack = y + 1`,而自己的序号`seq = x + 1`,
`TCP的标准规定：ACK报文可以携带数据。但如果不携带数据则 不消耗序号`。在这种情况下，下一个数据报文段的序号仍为
` seq = x + 1`。这时,TCP连接已经建立，A进入`ESTABLISHED(已建立连接)`状态。

当B收到A的确认后，也进入`ESTABLISHED(已建立连接)`状态。

为什么A最后还要再发送一次确认呢？主要是为了防止**已失效的连接请求报文段突然又传送到了B，因而产生错误。**

所谓`已失效的连接请求报文段`是这样产生的。考虑一种正常情况，A发出连接请求，但因连接请求报文段丢失而未收到确认。于是
A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A共发送了2次请求连接报文段，其中第一
个丢失，第二个到达了B，没有“已失效的连接请求报文段”。

现假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到在连接释
放的某个时间才到达B。本来这是一个早已失效的报文段。但B收到此失效的连接请求报文段后，**就误认为是A又发出了一次新的
连接请求**。于是就向A发出确认报文段，同意建立连接。假定不采用第三次报文握手，那么只要B发出确认，新的连接就建立了。

由于现在A并没有发出建立连接的请求，因此不会理财B的确认，也不会向B发送数据，但B却以为新的传输连接已经建立了，并一直
等待A发来数据。B的许多资源就这样白白浪费掉了。

采用三次报文握手的办法，可以防止上述现象的发生。例如刚才的异常情况下，A不会向B的确认发出确认。B由于收不到确认，就知道
A并没有要求建立连接。